#! /usr/bin/env python

import gzip
import argparse
import signal
import sys
import re
from functools import total_ordering


@total_ordering
class Segment:
    def __init__(self, name, start, end, isRev):
        self.name = name
        self.start = int(start)
        self.end = int(end)
        self.isRev = isRev
        self.length = self.end - self.start + 1

    def __str__(self):
        if self.isRev:
            return "{0}:{2}>{1}".format(self.name, self.start, self.end)
        else:
            return "{0}:{1}<{2}".format(self.name, self.start, self.end)
        
    def __lt__(self, other):
        if not isinstance(other, Segment):
            raise AttributeError("Incorrect attribute")
        if self.name != other.name:
            return self.name < other.name
        elif self.isRev != other.isRev:
            return other.isRev
        elif self.start != other.start:
            return self.start < other.start
        else:
            return self.end < other.end
        
    def __eq__(self, other):
        if not isinstance(other, Segment):
            raise AttributeError("Incorrect attribute")
        return self.name == other.name and self.start == other.start and \
            self.end == other.end and self.isRev == other.isRev

    @classmethod
    def generateFromStr(self, segStr):
        splited_1 = segStr.split(":")
        name = splited_1[0]
        region = splited_1[1]
        if "<" in region:
            splited_2 = region.split("<")
            start = splited_2[0]
            end = splited_2[1]
            isRev = False
        else:
            splited_2 = region.split(">")
            start = splited_2[1]
            end = splited_2[0]
            isRev = True
        
        return self(name, start, end, isRev)
    
    def cat(self, other, maxGap = 0.1):
        if not isinstance(other, Segment):
            raise AttributeError("Connot concatenate!")
        
        if self.isRev != other.isRev or self.name != other.name:
            # print("{0} and {1} cannot be concatenated.".format(self, other))
            return self
        gap = (self.length + other.length) * maxGap if maxGap < 1 else maxGap
        if other.start < self.start:
            if other.end > self.end:
                return other
            elif self.start - other.end < gap:
                return Segment(self.name, other.start, self.end, self.isRev)
            else:
                return self
        elif other.end < self.end:
            return self
        elif other.start - self.end < gap:
                return Segment(self.name, self.start, other.end, self.isRev)
        else:
            return self
        
    def isCatableWith(self, other, maxGap = 0.1):
        if not isinstance(other, Segment):
            return False
        if self.isRev != other.isRev:
            return False
        gap = (self.length + other.length) * maxGap if maxGap < 1 else maxGap
        if other.start < self.start:
            return self.start - other.end < gap
        else:
            return other.start - self.end < gap
        
    def isWithin(self, other):
        if not isinstance(other, Segment):
            raise AttributeError("Incorrect attribute")
        return self.name == other.name and self.isRev == other.isRev and \
            self.start >= other.start and self.end <= other.end
    
    def reverse(self):
        self.isRev = not self.isRev


def getMainSegment(segList, ignore):
    sortedList = sorted(segList)
    tmpSeg = None
    combinedList = []

    for seg in sortedList:
        if seg.name == ignore:
            continue
        if tmpSeg:
            if tmpSeg.isCatableWith(seg):
                tmpSeg = tmpSeg.cat(seg)
            else:
                combinedList.append(tmpSeg)
                tmpSeg = seg
        else:
            tmpSeg = seg
    combinedList.append(tmpSeg)
    
    if len(combinedList) < 1:
        return
    if len(combinedList) == 1:
        return combinedList[0]

    lengthList = [x.length for x in combinedList]
    totalLen = sum(lengthList)
    sortedLenList = sorted(lengthList, reverse=True)
    if (sortedLenList[0] - sortedLenList[1]) / totalLen > 0.2:
        return combinedList[lengthList.index(sortedLenList[0])]

def openFile(fileName):
    if fileName == "-":
        return sys.stdin
    if fileName.endswith(".gz"):
        return gzip.open(fileName, "rt")
    return open(fileName)

def segmentsFromLines(lines):
    for line in lines:
        stripped = line.strip()
        if not stripped:
            continue
        if stripped.startswith("SW") or stripped.startswith("score"):
            continue
        fields = stripped.split()
        qrySeq = fields[4]
        qryBeg = int(fields[5])
        qryEnd = int(fields[6])
        isRev = fields[8] == "C"
        rptFam = fields[10]
        rptBeg = int(fields[13] if isRev else fields[11])
        rptEnd = int(fields[12])
        pos = qrySeq, qryBeg, qryEnd
        data = isRev, rptFam, rptBeg, rptEnd
        yield pos, data

def groupsFromLines(lines):
    title = ""
    for line in lines:
        if line.startswith("# PART"):  # alignment starts
            yield title, textList, segList
            break
        stripped = line.rstrip()
        fields = stripped.split()
        if len(fields) < 2:
            continue
        if fields[1].startswith("group"):
            if title:
                yield title, textList, segList
            title = fields[1]
            textList = []
            segList = []
        elif fields[1].endswith("+") or fields[1].endswith("-"):
            textList.append(stripped)
            segList.append(fields[2:])
        elif re.match("\w+:\d+[<>]\d+", fields[1]):
            textList.append(stripped)
            segList[-1] += fields[1:]

def filterByGroups(inFile, outFile, segs, insert):
    passedGroup = []
    for group, textList, segList in groupsFromLines(inFile):
        segNums = list(map(lambda x: len(x), segList))
        if sum(segNums) / len(segNums) > 2:
            # Do nothing if there're more than 2 segments in the rearranegment.
            continue
        isUpstream = None
        isInsRev = None
        refName = ""
        refBeg = sys.maxsize
        refEnd = 0
        for readsAlns in segList:
            if isUpstream is None:
                isUpstream = readsAlns[0].startswith(insert)
            if isUpstream:
                refSeq = readsAlns[1]
                insSeq = readsAlns[0]
            else:
                refSeq = readsAlns[0]
                insSeq = readsAlns[1]
            
            if isInsRev is None:
                isInsRev = ">" in insSeq
            
            refData = refSeq.split(":")
            if not refName:
                refName = refData[0]
            refPos = refData[1].split("<")
            refBeg = min(int(refPos[0]), refBeg)
            refEnd = max(int(refPos[1]), refEnd)

        remover = False
        for key in segs:
            if remover:
                break
            qryName, qryBeg, qryEnd = key
            if qryName == refName:
                if isUpstream:
                    posRemover = qryBeg <= refBeg and refBeg <= qryEnd
                else:
                    posRemover = qryBeg <= refEnd and refEnd <= qryEnd

                if posRemover:
                    isRev, rptFam, rptBeg, rptEnd = segs[key]
                    remover = isRev == isInsRev
        
        if not remover:
            passedGroup.append(group)
            print("#", group, sep=" ", file=outFile)
            print(*textList, sep="\n", file=outFile)
            print("\n", file=outFile)
    # end of iteration in groupsFromLines
    
    print("%d groups passed the filter." % (len(passedGroup)))
    line = inFile.readline()
    if passedGroup[0].startswith("group1-"):
        print("#", "PART", passedGroup[0], sep=" ", file=outFile)
        print("\n", file=outFile)
        while not line[0] == "#":
            print(line, end="", file=outFile)
            line = inFile.readline()
    else:
        while not line[0] == "#":
            line = inFile.readline()
    
    outputFlag = False
    while line:
        if line[0] == "#":
            group = line.split()[2]
            outputFlag = group in passedGroup

        if outputFlag:
            print(line, end="", file=outFile)

        line = inFile.readline()

def main(args):
    segs = dict(segmentsFromLines(openFile(args.seg)))
    inFile = openFile(args.input)
    outFile = open(args.output + ".maf", "w+")

    if args.a:
        pass
    else:
        filterByGroups(inFile, outFile, segs, args.insert)

    inFile.close()
    outFile.close()


if __name__ == "__main__":
    signal.signal(signal.SIGPIPE, signal.SIG_DFL)  # avoid silly error message
    parser = argparse.ArgumentParser()
    parser.add_argument("--seg", help="segment file", required=True)
    parser.add_argument("--insert", help="insertion segment name", required=True)
    # parser.add_argument("--gap", help="(default 0) set a gap for both ends", default=0, type=int)
    # parser.add_argument("-a", help="filter by alignment", action="store_true")
    parser.add_argument("-i", "--input", help="input maf file", required=True)
    parser.add_argument("-o", "--output", help="output prefix", required=True)
    args = parser.parse_args()
    args.a = None
    main(args)
    


    





